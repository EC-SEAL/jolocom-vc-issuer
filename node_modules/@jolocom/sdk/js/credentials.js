"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialIssuer = exports.CredentialKeeper = exports.CredentialType = void 0;
const protocol_ts_1 = require("@jolocom/protocol-ts");
const util_1 = require("./util");
const signedCredential_1 = require("jolocom-lib/js/credentials/signedCredential/signedCredential");
const linkedData_1 = require("jolocom-lib/js/linkedData");
// TODO actually move into jolocom-lib??
class CredentialType {
    constructor(type, metadata) {
        var _a;
        this.type = type;
        this.definition = (metadata === null || metadata === void 0 ? void 0 : metadata.credential) || {};
        // NOTE: support for deprecated 'renderInfo'
        this.renderAs = ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.renderInfo) === null || _a === void 0 ? void 0 : _a.renderAs) || protocol_ts_1.CredentialRenderTypes.claim;
        // TODO add check against schema in definition
        this.issuerProfile = metadata === null || metadata === void 0 ? void 0 : metadata.issuer;
    }
    display(claim) {
        const display = {
            properties: [],
        };
        if (this.definition.display) {
            Object.keys(this.definition.display).forEach((k) => {
                const val = this.definition.display[k];
                if (Array.isArray(val)) {
                    // it's the 'properties' array
                    display[k] = val.map((dm) => this._processDisplayMapping(dm, claim));
                }
                else {
                    // one of 'title', 'subtitle', 'description'
                    display[k] = this._processDisplayMapping(val, claim);
                }
            });
        }
        return {
            type: this.type,
            issuerProfile: this.issuerProfile,
            name: this.definition.name || this.type.join(", "),
            schema: this.definition.schema || '',
            display: display,
            styles: {
                ...this.definition.styles,
            },
        };
    }
    _processDisplayMapping(dm, claim) {
        var _a;
        let value;
        const key = claim
            ? (_a = dm.path) === null || _a === void 0 ? void 0 : _a.find((p) => {
                // the paths are jsonpath
                value = util_1.jsonpath(p, claim);
                return value !== undefined;
            }) : undefined;
        return {
            label: dm.label,
            key,
            value: value !== undefined ? value : dm.text,
        };
    }
}
exports.CredentialType = CredentialType;
class CredentialKeeper {
    constructor(storage, resolver, filter) {
        this.storage = storage;
        this.resolver = resolver;
        this._applyFilter = typeof filter === 'function' ? filter : () => filter;
    }
    /**
     * Retrieves a Signed Credential by id, or throws
     *
     * @param credParams - credential attributes
     * @returns SignedCredential instance
     * @category Credential Management
     */
    async get(id) {
        const creds = await this.query({ id });
        if (creds.length !== 1)
            throw new Error('multiple results for cred id ' + id);
        return creds[0];
    }
    async query(attrs, options) {
        const filterVals = this._applyFilter();
        return await this.storage.get.verifiableCredential({
            ...attrs,
            ...filterVals,
        });
    }
    async delete(attrs) {
        // we use this.find to apply the filter if any
        const creds = await this.query(attrs);
        if (creds.length === 0)
            return false;
        await creds.map(({ id }) => this.storage.delete.verifiableCredential(id));
        return true;
    }
    async storeCredentialType(metadata) {
        await this.storage.store.credentialMetadata(metadata);
        await this.storage.store.issuerProfile(metadata.issuer);
    }
    async getCredentialType(cred) {
        const metadata = await this.storage.get.credentialMetadata(cred);
        if (!metadata.issuer) {
            try {
                metadata.issuer = await this.storage.get.publicProfile(cred.issuer);
            }
            catch (err) {
                console.error(`could not lookup issuer ${cred.issuer}`, err);
                // pass
            }
        }
        return new CredentialType(cred.type, metadata);
    }
    async display(cred) {
        const credType = await this.getCredentialType(cred);
        return credType.display(cred.claim);
    }
    async verify(cred) {
        const issuer = await this.resolver.resolve(cred.issuer);
        const json = cred instanceof signedCredential_1.SignedCredential ? cred.toJSON() : cred;
        return linkedData_1.validateJsonLd(json, issuer);
    }
}
exports.CredentialKeeper = CredentialKeeper;
class CredentialIssuer extends CredentialKeeper {
    constructor(agent, filter) {
        super(agent.storage, agent.resolver, filter);
        this.issue = this.create;
        this.agent = agent;
    }
    /**
     * Creates and signs a Credential, and commits it to storage.
     *
     * @param credParams - credential attributes
     * @returns SignedCredential instance
     * @category Credential Management
     */
    async create(credParams) {
        const cred = await this.agent.idw.create.signedCredential(credParams, await this.agent.passwordStore.getPassword());
        // FIXME TODO: issuers currently can't store the cred in their DB because it
        // requires a foreign link to the subject... so only self-signed creds work
        // Otherwise it throws
        if (cred.issuer === cred.subject) {
            await this.storage.store.verifiableCredential(cred);
        }
        return cred;
    }
}
exports.CredentialIssuer = CredentialIssuer;
//# sourceMappingURL=credentials.js.map